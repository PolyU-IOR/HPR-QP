# Input Methods Overview

HPRLP supports three different ways to specify and solve linear programming problems. Choose the method that best fits your workflow.

## Quick Comparison

| Method | Best For | Key Advantage | When to Use |
|--------|----------|---------------|-------------|
| [**JuMP Integration**](jump_integration.md) | Model building in Julia | High-level modeling language | Building models programmatically with algebraic syntax |
| [**MPS Files**](mps_files.md) | Standard format files | Industry compatibility | Reading benchmarks or problems from other tools |
| [**Direct API**](direct_api.md) | Matrix-based input | Full control, no overhead | Working with pre-built matrices or custom algorithms |

## Choosing Your Input Method

### Use JuMP Integration if you:
- ✓ Want to build models using algebraic expressions
- ✓ Need a high-level, readable problem formulation
- ✓ Are familiar with optimization modeling languages (like AMPL, GAMS)
- ✓ Want to easily switch between different solvers
- ✓ Prefer working with variables, constraints, and objectives directly

**Example use case:** Building a production planning model where you define decision variables and constraints naturally.

```julia
using JuMP, HPRLP
model = Model(HPRLP.Optimizer)
@variable(model, x >= 0)
@variable(model, y >= 0)
@objective(model, Max, 3x + 5y)
@constraint(model, x + 2y <= 10)
optimize!(model)
```

[→ See JuMP Integration Guide](jump_integration.md)

---

### Use MPS Files if you:
- ✓ Have problems in MPS format from benchmarks (NETLIB, MIPLIB, etc.)
- ✓ Need to read problems generated by other optimization tools
- ✓ Want to use standard LP test sets
- ✓ Are comparing solver performance on established benchmarks
- ✓ Receive problem files from collaborators or other software

**Example use case:** Solving benchmark problems from the NETLIB test set or problems exported from commercial optimization software.

```julia
using HPRLP
model = build_from_mps("path/to/problem.mps")
params = HPRLP_parameters()
result = optimize(model, params)
```

[→ See MPS Files Guide](mps_files.md)

---

### Use Direct API if you:
- ✓ Already have your problem in matrix form
- ✓ Need maximum performance (no modeling overhead)
- ✓ Are implementing custom algorithms or research code
- ✓ Work with problems generated from scientific computing
- ✓ Want precise control over the problem formulation
- ✓ Are integrating HPRLP into existing numerical code

**Example use case:** Solving LP subproblems in a decomposition algorithm where constraint matrices are built programmatically.

```julia
using HPRLP, SparseArrays
A = sparse([...])  # Your constraint matrix
model = build_from_Abc(A, c, AL, AU, l, u)
params = HPRLP_parameters()
result = optimize(model, params)
```

[→ See Direct API Guide](direct_api.md)

---

## Can I Use Multiple Methods?

**Yes!** You can use different input methods in the same project. For example:
- Use JuMP for rapid prototyping, then switch to Direct API for production
- Validate your Direct API implementation against MPS benchmark files
- Build models in JuMP and export/import via MPS format

## What's Next?

1. **Choose your input method** using the guide above
2. **Configure solver parameters** in the [Parameters](parameters.md) guide
3. **Understand the results** in the [Output & Results](output_results.md) guide

## Standard Form

Regardless of input method, HPRLP internally solves problems in the standard form:

```math
\begin{array}{ll}
\min \quad & c^T x + c_0\\
\text{s.t.} \quad & AL \leq Ax \leq AU \\
& l \leq x \leq u
\end{array}
```

- **JuMP** automatically converts your model to this form
- **MPS files** are parsed into this representation  
- **Direct API** lets you specify this form directly
