# Input Methods Overview

HPRQP supports three different ways to specify and solve quadratic programming problems. Choose the method that best fits your workflow.

## Quick Comparison

| Method | Best For | Key Advantage | When to Use |
|--------|----------|---------------|-------------|
| [**JuMP Integration**](jump_integration.md) | Model building in Julia | High-level modeling language | Building models programmatically with algebraic syntax |
| [**MPS Files**](mps_files.md) | Standard format files | Industry compatibility | Reading benchmarks or problems from other tools |
| [**Direct API**](direct_api.md) | Matrix-based input | Full control, no overhead | Working with pre-built matrices or custom algorithms |

## Choosing Your Input Method

### Use JuMP Integration if you:
- ✓ Want to build models using algebraic expressions
- ✓ Need a high-level, readable problem formulation
- ✓ Are familiar with optimization modeling languages (like AMPL, GAMS)
- ✓ Want to easily switch between different solvers
- ✓ Prefer working with variables, constraints, and objectives directly

**Example use case:** Building a portfolio optimization model with quadratic risk terms.

```julia
using JuMP, HPRQP
model = Model(HPRQP.Optimizer)
@variable(model, x[1:n] >= 0)
@objective(model, Min, sum(x[i]^2 for i in 1:n) + sum(c[i]*x[i] for i in 1:n))
@constraint(model, sum(x) == 1)
optimize!(model)
```

[→ See JuMP Integration Guide](jump_integration.md)

---

### Use MPS Files if you:
- ✓ Have problems in MPS format from benchmarks (MAROS, CUTEst, etc.)
- ✓ Need to read problems generated by other optimization tools
- ✓ Want to use standard QP test sets
- ✓ Are comparing solver performance on established benchmarks
- ✓ Receive problem files from collaborators or other software

**Example use case:** Solving benchmark QP problems from standard test sets or problems exported from MATLAB/GAMS.

```julia
using HPRQP
model = build_from_mps("path/to/qp_problem.mps")
params = HPRQP_parameters()
result = optimize(model, params)
```

[→ See MPS Files Guide](mps_files.md)

---

### Use Direct API if you:
- ✓ Already have your problem in matrix form
- ✓ Need maximum performance (no modeling overhead)
- ✓ Are implementing custom algorithms or research code
- ✓ Work with problems generated from scientific computing
- ✓ Want precise control over the problem formulation and Q operator
- ✓ Are integrating HPRQP into existing numerical code

**Example use case:** Solving QP subproblems in a decomposition algorithm or using specialized Q operators for structured problems.

```julia
using HPRQP, SparseArrays
Q = sparse([...])  # Your quadratic term
A = sparse([...])  # Your constraint matrix
model = build_from_QAbc(Q, A, c, AL, AU, l, u)
params = HPRQP_parameters()
result = optimize(model, params)
```

[→ See Direct API Guide](direct_api.md)

---

## Can I Use Multiple Methods?

**Yes!** You can use different input methods in the same project. For example:
- Use JuMP for rapid prototyping, then switch to Direct API for production
- Validate your Direct API implementation against MPS benchmark files
- Build models in JuMP and export/import via MPS format

## Understanding Q Operators

HPRQP supports different representations of the quadratic term Q:

1. **Sparse Matrix** - For general sparse quadratic problems
2. **LASSO Operator** - For L1-regularized least squares (||Ax - b||² + λ||x||₁)
3. **QAP Operator** - For quadratic assignment problems
4. **Custom Operators** - Define your own matrix-free operators

[→ See Q Operators Overview](q_operators_overview.md)

## What's Next?

1. **Choose your input method** using the guide above
2. **Understand Q operators** for your problem type
3. **Configure solver parameters** in the [Parameters](parameters.md) guide
4. **Understand the results** in the [Output & Results](output_results.md) guide

## Standard Form

Regardless of input method, HPRQP internally solves problems in the standard form:

```math
\begin{array}{ll}
\min \quad & \frac{1}{2} \langle x, Qx \rangle + \langle c, x \rangle + c_0\\
\text{s.t.} \quad & AL \leq Ax \leq AU \\
& l \leq x \leq u
\end{array}
```

- **JuMP** automatically converts your model to this form
- **MPS files** are parsed into this representation  
- **Direct API** lets you specify this form directly
